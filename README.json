{
  "main.py:prelude": {
    "beg": 3,
    "end": 16,
    "txt": [
      [
        4,
        "\"\"\"\n"
      ],
      [
        5,
        "Quick-and-dirty \"literate programming\" tool to extract code from Markdown files\n"
      ],
      [
        6,
        "\n"
      ],
      [
        7,
        "Copyright (c) 2022 Javier Escalada G\u00f3mez  \n"
      ],
      [
        8,
        "All rights reserved.\n"
      ],
      [
        9,
        "License: BSD 3-Clause Clear License (see LICENSE for details)\n"
      ],
      [
        10,
        "\"\"\"\n"
      ],
      [
        11,
        "\n"
      ],
      [
        12,
        "__author__ = \"Javier Escalada G\u00f3mez\"\n"
      ],
      [
        13,
        "__email__ = \"kerrigan29a@gmail.com\"\n"
      ],
      [
        14,
        "__version__ = \"0.0.2\"\n"
      ],
      [
        15,
        "__license__ = \"BSD 3-Clause Clear License\"\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "prelude"
  },
  "main.py:Code block patterns": {
    "beg": 32,
    "end": 35,
    "txt": [
      [
        33,
        "FENCE = re.compile(r'( {0,3})(`{3,}|~{3,})(.*)')\n"
      ],
      [
        34,
        "OPT = re.compile(r' *(\\S+)')\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "Code block patterns"
  },
  "main.py:label_markdown_lines": {
    "beg": 50,
    "end": 76,
    "txt": [
      [
        51,
        "def label_lines(f):\n"
      ],
      [
        52,
        "    is_code = False\n"
      ],
      [
        53,
        "    is_ignored_code = False\n"
      ],
      [
        54,
        "    for i, l in enumerate(f):\n"
      ],
      [
        55,
        "        if m := FENCE.match(l):\n"
      ],
      [
        56,
        "            indent, leader, rest = m.groups()\n"
      ],
      [
        57,
        "            if leader != '~~~' or is_ignored_code:\n"
      ],
      [
        58,
        "                yield (\"TEXT\", l, i+1)\n"
      ],
      [
        59,
        "                is_ignored_code = not is_ignored_code\n"
      ],
      [
        60,
        "            elif not is_code:\n"
      ],
      [
        61,
        "                opts = OPT.findall(rest)\n"
      ],
      [
        62,
        "                if len(opts) < 2 or leader != '~~~':\n"
      ],
      [
        63,
        "                    yield (\"TEXT\", l, i+1)\n"
      ],
      [
        64,
        "                    is_ignored_code = True\n"
      ],
      [
        65,
        "                elif not is_ignored_code:\n"
      ],
      [
        66,
        "                    lang, filename, desc = opts[0], opts[1], \" \".join(opts[2:])\n"
      ],
      [
        67,
        "                    yield (\"BEGIN\", indent, lang, filename, desc, l, i+1)\n"
      ],
      [
        68,
        "                    is_code = True\n"
      ],
      [
        69,
        "            else:\n"
      ],
      [
        70,
        "                yield (\"END\", l, i+1)\n"
      ],
      [
        71,
        "                is_code = False\n"
      ],
      [
        72,
        "        elif is_code:\n"
      ],
      [
        73,
        "            yield (\"CODE\", l, i+1)\n"
      ],
      [
        74,
        "        else:\n"
      ],
      [
        75,
        "            yield (\"TEXT\", l, i+1)\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "label_markdown_lines"
  },
  "main.py:extract_blocks": {
    "beg": 80,
    "end": 103,
    "txt": [
      [
        81,
        "def extract_blocks(lines):\n"
      ],
      [
        82,
        "    block = None\n"
      ],
      [
        83,
        "    block_indent = None\n"
      ],
      [
        84,
        "    for line in lines:\n"
      ],
      [
        85,
        "        match line:\n"
      ],
      [
        86,
        "            case (\"BEGIN\", indent, lang, filename, desc, _, linenum):\n"
      ],
      [
        87,
        "                block = {\n"
      ],
      [
        88,
        "                    \"beg\": linenum,\n"
      ],
      [
        89,
        "                    \"end\": None,\n"
      ],
      [
        90,
        "                    \"txt\": [],\n"
      ],
      [
        91,
        "                    \"lang\": lang,\n"
      ],
      [
        92,
        "                    \"filename\": filename,\n"
      ],
      [
        93,
        "                    \"desc\": desc,\n"
      ],
      [
        94,
        "                }\n"
      ],
      [
        95,
        "                block_indent = indent\n"
      ],
      [
        96,
        "            case (\"END\", _, linenum):\n"
      ],
      [
        97,
        "                block[\"end\"] = linenum\n"
      ],
      [
        98,
        "                yield block\n"
      ],
      [
        99,
        "                block = None\n"
      ],
      [
        100,
        "                block_indent = None\n"
      ],
      [
        101,
        "            case (\"CODE\", raw_line, linenum):\n"
      ],
      [
        102,
        "                block[\"txt\"].append((linenum, raw_line.removeprefix(block_indent)))\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "extract_blocks"
  },
  "main.py:index_blocks": {
    "beg": 109,
    "end": 115,
    "txt": [
      [
        110,
        "def index_blocks(blocks):\n"
      ],
      [
        111,
        "    index = {}\n"
      ],
      [
        112,
        "    for block in blocks:\n"
      ],
      [
        113,
        "        index[(block[\"filename\"], block[\"desc\"])] = block\n"
      ],
      [
        114,
        "    return index\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "index_blocks"
  },
  "main.py:walk_blocks": {
    "beg": 121,
    "end": 145,
    "txt": [
      [
        122,
        "def walk_blocks(src_block, dst_blocks, input_filename):\n"
      ],
      [
        123,
        "\n"
      ],
      [
        124,
        "    # <<< write_line >>>\n"
      ],
      [
        125,
        "\n"
      ],
      [
        126,
        "    src_lang = src_block[\"lang\"]\n"
      ],
      [
        127,
        "    src_filename = src_block[\"filename\"]\n"
      ],
      [
        128,
        "    ref_pattern = LANG_REF_PATTERNS[src_lang]\n"
      ],
      [
        129,
        "\n"
      ],
      [
        130,
        "    yield line_directive(src_block[\"beg\"])\n"
      ],
      [
        131,
        "    for linenum, src_line in src_block[\"txt\"]:\n"
      ],
      [
        132,
        "        if m := ref_pattern.match(src_line):\n"
      ],
      [
        133,
        "            dst_indent, dst_name = m.groups()\n"
      ],
      [
        134,
        "            dst_block = dst_blocks[(src_filename, dst_name.strip())]\n"
      ],
      [
        135,
        "            if dst_block == src_block:\n"
      ],
      [
        136,
        "                raise ValueError(f\"detected self-reference in {input_filename} at line {linenum}\")\n"
      ],
      [
        137,
        "            dst_lang = dst_block[\"lang\"]\n"
      ],
      [
        138,
        "            if src_lang != dst_lang:\n"
      ],
      [
        139,
        "                raise ValueError(f\"language mismatch: {src_lang} != {dst_lang}\")\n"
      ],
      [
        140,
        "            for l in walk_blocks(dst_block, dst_blocks, input_filename):\n"
      ],
      [
        141,
        "                yield dst_indent + l\n"
      ],
      [
        142,
        "            yield dst_indent + line_directive(linenum)\n"
      ],
      [
        143,
        "        else:\n"
      ],
      [
        144,
        "            yield src_line\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "walk_blocks"
  },
  "main.py:reference_patterns": {
    "beg": 149,
    "end": 160,
    "txt": [
      [
        150,
        "REF_PATTERN = re.compile(r'<<<(.+)>>>')\n"
      ],
      [
        151,
        "PYTHON_REF_PATTERN = re.compile(r'( *)#[ \\t]*' + REF_PATTERN.pattern)\n"
      ],
      [
        152,
        "C_REF_PATTERN = re.compile(r'( *)//[ \\t]*' + REF_PATTERN.pattern)\n"
      ],
      [
        153,
        "LANG_REF_PATTERNS = {\n"
      ],
      [
        154,
        "    \"python\": PYTHON_REF_PATTERN,\n"
      ],
      [
        155,
        "    \"py\": PYTHON_REF_PATTERN,\n"
      ],
      [
        156,
        "    \"c\": C_REF_PATTERN,\n"
      ],
      [
        157,
        "    \"cpp\": C_REF_PATTERN,\n"
      ],
      [
        158,
        "    \"go\": C_REF_PATTERN,\n"
      ],
      [
        159,
        "}\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "reference_patterns"
  },
  "main.py:compose_warning_message": {
    "beg": 173,
    "end": 178,
    "txt": [
      [
        174,
        "def compose_warning_message(input, lang):\n"
      ],
      [
        175,
        "    comment_format = LANG_COMMENT_FORMATS[lang]\n"
      ],
      [
        176,
        "    yield comment_format.format(f\"Code generated from {input}; DO NOT EDIT.\") + \"\\n\"\n"
      ],
      [
        177,
        "    yield comment_format.format(f\"Command used: {' '.join(sys.argv)}\") + \"\\n\"\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "compose_warning_message"
  },
  "main.py:comment_formats": {
    "beg": 182,
    "end": 192,
    "txt": [
      [
        183,
        "PYTHON_COMMENT_FORMAT = \"# {0}\"\n"
      ],
      [
        184,
        "C_COMMENT_FORMAT = \"// {0}\"\n"
      ],
      [
        185,
        "LANG_COMMENT_FORMATS = {\n"
      ],
      [
        186,
        "    \"python\": PYTHON_COMMENT_FORMAT,\n"
      ],
      [
        187,
        "    \"py\": PYTHON_COMMENT_FORMAT,\n"
      ],
      [
        188,
        "    \"c\": C_COMMENT_FORMAT,\n"
      ],
      [
        189,
        "    \"cpp\": C_COMMENT_FORMAT,\n"
      ],
      [
        190,
        "    \"go\": C_COMMENT_FORMAT,\n"
      ],
      [
        191,
        "}\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "comment_formats"
  },
  "main.py:write_line": {
    "beg": 196,
    "end": 200,
    "txt": [
      [
        197,
        "line_format = LANG_LINE_FORMATS[src_block[\"lang\"]]\n"
      ],
      [
        198,
        "def line_directive(line):\n"
      ],
      [
        199,
        "    return line_format.format(file=input_filename, line=line+1) + \"\\n\"\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "write_line"
  },
  "main.py:line_formats": {
    "beg": 204,
    "end": 215,
    "txt": [
      [
        205,
        "PYTHON_MAP_FORMAT = \"#line {file}:{line}\"\n"
      ],
      [
        206,
        "C_MAP_FORMAT = \"#line {line} {file}\"\n"
      ],
      [
        207,
        "GO_MAP_FORMAT = \"//line {file}:{line}\"\n"
      ],
      [
        208,
        "LANG_LINE_FORMATS = {\n"
      ],
      [
        209,
        "    \"python\": PYTHON_MAP_FORMAT,\n"
      ],
      [
        210,
        "    \"py\": PYTHON_MAP_FORMAT,\n"
      ],
      [
        211,
        "    \"c\": C_MAP_FORMAT,\n"
      ],
      [
        212,
        "    \"cpp\": C_MAP_FORMAT,\n"
      ],
      [
        213,
        "    \"go\": GO_MAP_FORMAT,\n"
      ],
      [
        214,
        "}\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "line_formats"
  },
  "main.py:parse_arguments": {
    "beg": 222,
    "end": 249,
    "txt": [
      [
        223,
        "class ParseError(Exception):\n"
      ],
      [
        224,
        "    pass\n"
      ],
      [
        225,
        "\n"
      ],
      [
        226,
        "def parse_args():\n"
      ],
      [
        227,
        "    parser = argparse.ArgumentParser(\n"
      ],
      [
        228,
        "        description='Quick-and-dirty \"literate programming\" tool to extract code from Markdown files')\n"
      ],
      [
        229,
        "    parser.add_argument(\"input\", metavar='FILE',\n"
      ],
      [
        230,
        "        help=\"Input Markdown file\")\n"
      ],
      [
        231,
        "    parser.add_argument(\"-e\", \"--encoding\", metavar='ENCODING', default=\"utf-8\", \n"
      ],
      [
        232,
        "        help=\"Encoding (default: %(default)s)\")\n"
      ],
      [
        233,
        "    parser.add_argument(\"-r\", \"--rename\", metavar='OLD_NAME:NEW_NAME', action='append',\n"
      ],
      [
        234,
        "        help=\"Rename a file in the input Markdown file\")\n"
      ],
      [
        235,
        "    parser.add_argument(\"-o\", \"--overwrite\", action='store_true',\n"
      ],
      [
        236,
        "        help=\"Overwrite output files (default: %(default)s)\")\n"
      ],
      [
        237,
        "    parser.add_argument(\"-D\", \"--dump\", action='store_true',\n"
      ],
      [
        238,
        "        help=\"Dump the internal state(default: %(default)s)\")\n"
      ],
      [
        239,
        "    args = parser.parse_args()\n"
      ],
      [
        240,
        "    rename = {}\n"
      ],
      [
        241,
        "    for r in args.rename or []:\n"
      ],
      [
        242,
        "        try:\n"
      ],
      [
        243,
        "            old, new = r.split(\":\")\n"
      ],
      [
        244,
        "        except ValueError:\n"
      ],
      [
        245,
        "            raise ParseError(f\"invalid rename format: {r}\\nIt must follow the format OLD_NAME:NEW_NAME\")\n"
      ],
      [
        246,
        "        rename[old] = new\n"
      ],
      [
        247,
        "    args.rename = rename\n"
      ],
      [
        248,
        "    return args\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "parse_arguments"
  },
  "main.py:run": {
    "beg": 253,
    "end": 303,
    "txt": [
      [
        254,
        "CRED = \"\\033[31m\"\n"
      ],
      [
        255,
        "CGREEN = \"\\033[32m\"\n"
      ],
      [
        256,
        "CYELLOW = \"\\033[33m\"\n"
      ],
      [
        257,
        "CBOLD = \"\\033[1m\"\n"
      ],
      [
        258,
        "CDIM = \"\\033[2m\"\n"
      ],
      [
        259,
        "CEND = \"\\033[0m\"\n"
      ],
      [
        260,
        "\n"
      ],
      [
        261,
        "def perror(msg):\n"
      ],
      [
        262,
        "    print(f\"{CRED}  ERROR{CEND} - {msg}\")\n"
      ],
      [
        263,
        "\n"
      ],
      [
        264,
        "def pwarning(msg):\n"
      ],
      [
        265,
        "    print(f\"{CYELLOW}WARNING{CEND} - {msg}\")\n"
      ],
      [
        266,
        "\n"
      ],
      [
        267,
        "def pinfo(msg):\n"
      ],
      [
        268,
        "    print(f\"{CGREEN}   INFO{CEND} - {msg}\")\n"
      ],
      [
        269,
        "\n"
      ],
      [
        270,
        "def run(args):\n"
      ],
      [
        271,
        "    pinfo(f\"Reading {CDIM}{args.input}{CEND}\")\n"
      ],
      [
        272,
        "    with open(args.input, encoding=args.encoding) as f:\n"
      ],
      [
        273,
        "        blocks = index_blocks(extract_blocks(label_lines(f)))\n"
      ],
      [
        274,
        "    if args.dump:\n"
      ],
      [
        275,
        "        name, ext = os.path.splitext(args.input)\n"
      ],
      [
        276,
        "        with open(name + \".json\", \"w\", encoding=args.encoding) as f:\n"
      ],
      [
        277,
        "            tmp = {\":\".join(k): v for k, v in blocks.items()}\n"
      ],
      [
        278,
        "            json.dump(tmp, f, indent=2)\n"
      ],
      [
        279,
        "    for (filename, desc), block in blocks.items():\n"
      ],
      [
        280,
        "        if desc.lower() == \"main\":\n"
      ],
      [
        281,
        "            filename = args.rename.get(filename, filename)\n"
      ],
      [
        282,
        "            if os.path.exists(filename):\n"
      ],
      [
        283,
        "                if not args.overwrite:\n"
      ],
      [
        284,
        "                    perror(f\"{CDIM}{filename}{CEND} already exists.\")\n"
      ],
      [
        285,
        "                    pinfo(f\"Skipping {CDIM}{filename}{CEND}\")\n"
      ],
      [
        286,
        "                    return 1\n"
      ],
      [
        287,
        "                else:\n"
      ],
      [
        288,
        "                    pwarning(f\"{CDIM}{filename}{CEND} already exists.\")\n"
      ],
      [
        289,
        "                    pinfo(f\"Overwriting {CDIM}{filename}{CEND}\")\n"
      ],
      [
        290,
        "            else:\n"
      ],
      [
        291,
        "                pinfo(f\"Writing {CDIM}{filename}{CEND}\")\n"
      ],
      [
        292,
        "            with open(filename, \"w\", encoding=args.encoding) as f:\n"
      ],
      [
        293,
        "                for l in compose_warning_message(args.input, block[\"lang\"]):\n"
      ],
      [
        294,
        "                    f.write(l)\n"
      ],
      [
        295,
        "                f.write(\"\\n\\n\")\n"
      ],
      [
        296,
        "                try:\n"
      ],
      [
        297,
        "                    for l in walk_blocks(block, blocks, args.input):\n"
      ],
      [
        298,
        "                        f.write(l)\n"
      ],
      [
        299,
        "                except ValueError as e:\n"
      ],
      [
        300,
        "                    perror(e)\n"
      ],
      [
        301,
        "                    return 1\n"
      ],
      [
        302,
        "    return 0\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "run"
  },
  "main.py:main": {
    "beg": 306,
    "end": 350,
    "txt": [
      [
        307,
        "# <<< prelude >>>\n"
      ],
      [
        308,
        "\n"
      ],
      [
        309,
        "import re\n"
      ],
      [
        310,
        "import sys\n"
      ],
      [
        311,
        "import argparse\n"
      ],
      [
        312,
        "import os.path\n"
      ],
      [
        313,
        "import json\n"
      ],
      [
        314,
        "\n"
      ],
      [
        315,
        "# <<< Code block patterns >>>\n"
      ],
      [
        316,
        "\n"
      ],
      [
        317,
        "# <<< reference_patterns >>>\n"
      ],
      [
        318,
        "\n"
      ],
      [
        319,
        "# <<< comment_formats >>>\n"
      ],
      [
        320,
        "\n"
      ],
      [
        321,
        "# <<< line_formats >>>\n"
      ],
      [
        322,
        "\n"
      ],
      [
        323,
        "# <<< label_markdown_lines >>>\n"
      ],
      [
        324,
        "\n"
      ],
      [
        325,
        "# <<< extract_blocks >>>\n"
      ],
      [
        326,
        "\n"
      ],
      [
        327,
        "# <<< index_blocks >>>\n"
      ],
      [
        328,
        "\n"
      ],
      [
        329,
        "# <<< walk_blocks >>>\n"
      ],
      [
        330,
        "\n"
      ],
      [
        331,
        "# <<< compose_warning_message >>>\n"
      ],
      [
        332,
        "\n"
      ],
      [
        333,
        "# <<< parse_arguments >>>\n"
      ],
      [
        334,
        "    \n"
      ],
      [
        335,
        "# <<< run >>>\n"
      ],
      [
        336,
        "\n"
      ],
      [
        337,
        "def main():\n"
      ],
      [
        338,
        "    try:\n"
      ],
      [
        339,
        "        exit(run(parse_args()))\n"
      ],
      [
        340,
        "    except ParseError as e:\n"
      ],
      [
        341,
        "        perror(e)\n"
      ],
      [
        342,
        "    except Exception as e:\n"
      ],
      [
        343,
        "        import traceback\n"
      ],
      [
        344,
        "        perror(e)\n"
      ],
      [
        345,
        "        traceback.print_exc()\n"
      ],
      [
        346,
        "    exit(1)\n"
      ],
      [
        347,
        "\n"
      ],
      [
        348,
        "if __name__ == \"__main__\":\n"
      ],
      [
        349,
        "    main()\n"
      ]
    ],
    "lang": "python",
    "filename": "main.py",
    "desc": "main"
  },
  "script.py:main": {
    "beg": 352,
    "end": 361,
    "txt": [
      [
        353,
        "\n"
      ],
      [
        354,
        "# Copyright (c) 2022 Javier Escalada G\u00f3mez\n"
      ],
      [
        355,
        "# All rights reserved.\n"
      ],
      [
        356,
        "\n"
      ],
      [
        357,
        "from litterateur import main\n"
      ],
      [
        358,
        "\n"
      ],
      [
        359,
        "if __name__ == \"__main__\":\n"
      ],
      [
        360,
        "    main()\n"
      ]
    ],
    "lang": "python",
    "filename": "script.py",
    "desc": "main"
  }
}